# Git learn

[https://git-scm.com/book/ru/v2]

[https://github.com/github/gitignore]

`git add .` - для того чтобы начать отслеживать (добавить под версионный контроль) новый файл

`git branch <branchname>` - создать новую ветку. В результате создаётся новый указатель на текущий коммит. Как Git определяет, в какой ветке вы находитесь? Он хранит специальный указатель HEAD. HEAD — это указатель на текущую локальную ветку. В нашем случае мы всё ещё находимся в ветке master. Команда git branch только создаёт новую ветку, но не переключает на неё

`git checkout <branchname>` - переключение на существующую ветку. В результате указатель HEAD переместится на существующую ветку

`git checkout -b <newbranchname>` - при создании новой ветки сразу на неё переключиться

`git checkout -- <file>` — опасная команда. Все локальные изменения в файле пропадут — Git просто заменит его версией из последнего коммита. Ни в коем случае не используйте эту команду, если вы не уверены, что изменения в файле вам не нужны.

`git diff` - Чтобы увидеть, что же вы изменили, но пока не проиндексировали

`git diff --staged` - Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит

`git difftool`

`git fetch [remote-name]` - связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет

`git init`

`git config`

`git config --global alias.ci commit` - вместо ввода git commit, вам достаточно набрать только git ci

`git commit -m` - Git вычисляет контрольные суммы каждого подкаталога (в нашем случае, только основной каталог проекта) и сохраняет его в репозитории как объект дерева каталогов. Затем Git создаёт объект коммита с метаданными и указателем на основное дерево проекта для возможности воссоздать этот снимок в случае необходимости.

`git commit --amend` - Эта команда использует область подготовки (индекс) для внесения правок в коммит.

`git clone`

`git log`

`git log -p` - показывает разницу (выводит патч), внесённую в каждый коммит

`git log -stat` - сокращённая статистика для каждого коммита

`git log --oneline --decorate` - покажет куда указывают указатели веток

`git log --oneline --decorate --graph --all`

`git log --pretty=oneline` - меняет формат вывода

`git log --graph`

`git mv`

`git push <remote-name> <branch-name>` - git push origin master

`git push origin <tagname>` - После создания теги нужно отправлять явно на удалённый сервер

`git push origin --delete <tagname>` - убрать тег из внешнего репозитория

`git push <remote> :refs/tags/<tagname>` - обновление внешнего тега пустым значением, что приводит к его удалению

`git pull` - извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете

`git remote` - Просмотр удалённых репозиториев (origin — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование)

`git remote add <shortname> <url>` - добавить удалённый репозиторий и присвоить ему имя (shortname)

`git remote rename` - переименования удалённого репозитория

`git remote rm` - удалить удалённый репозиторий

`git remote -v` - просмотреть адреса для чтения и записи, привязанные к репозиторию

`git remote show <remote>` - выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках

`git reset` - для исключения из индекса

`git restore` - Откат изменённого файла

`git restore --staged` - Откат индексированного файла

`git rm` - Для того чтобы удалить файл из Git, вам необходимо удалить его из отслеживаемых файлов (точнее, удалить его из вашего индекса) а затем выполнить коммит.

`git status -s`

`git switch <branchname>` - Переключиться на существующую ветку

`git switch -c new-branch` - Создать новую ветку и переключиться на неё

`git switch -` - Вернуться к предыдущей извлечённой ветке

`git tag` - список имеющихся тегов в Git

`git tag -a -m` - Создание аннотированного тега в Git (-m сообщение, которое будет храниться вместе с тегом)

`git tag -d <tagname>` - удаления тега в локальном репозитории

## File statuses in Git

Untracked означает, что Git видит файл, которого не было в предыдущем снимке состояния (коммите); Git не станет добавлять его в ваши коммиты, пока вы его явно об этом не попросите

Changes not staged for commit — это означает, что отслеживаемый файл был изменён в рабочем каталоге, но пока не проиндексирован.

Changes to be committed
Если вы выполните коммит в этот момент, то версия файла, существовавшая на момент выполнения вами команды git add, будет добавлена в историю снимков состояния
